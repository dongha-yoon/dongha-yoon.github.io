<link rel="stylesheet" type="text/css" href="../../css/theme.css">

# [Chapter 5] CPU Scheduling

## 5.1 Basic Concepts

* **CPU scheduling의 목적 : Maximize CPU utilization!**

### CPU-I/O Burst Cycle

* Process execution은 *CPU execution*과 *I/O wait*으로 나누어진다.
* 프로그램은 실행 특성에 따라 구분할 수 있다
  * **CPU-bound program** : 적은 수의 long CPU burst
    * I/O보다는 직접적인 computation을 많이 하기 때문에 CPU 사용에 시간을 오랫동안 씀
  * **I/O-bound program** : 많은 수의 short CPU burst
    * I/O가 많기 때문에 짧은 시간동안 CPU를 이용하고 I/O대기에 쓰는 시간이 많음
* 이러한 구분이 CPU scheduling algorithm implementation에 큰 영향을 미침

### CPU scheduler

* CPU가 유휴상태(idle)가 되면 OS는 실행할 프로세스를 *ready queue*에서 골라 CPU를 할당해주어야 한다. 이 역할을 하는 것이 *CPU scheduler*다.
* Ready queue를 어떻게 구현하는가가 scheduling의 핵심. FIFO, priority, tree 등 다양한 방법으로 구현될 수 있으며 queue의 element로는 일반적으로 PCB가 들어간다.

### Preemptive and Nonpreemptive Scheduling

* CPU scheduling decision이 필요한 상황
  1. 프로세스가 running state에서 waiting state로 바뀌는 경우(ex. I/O 요청이 발생한 경우)
  2. 프로세스가 running state에서 ready state로 바뀌는 경우(ex. interrupt가 발생한 경우)
  3. 프로세스가 waiting state에서 ready state로 바뀌는 경우(ex. I/O 요청 처리를 끝낸 경우)
  4. 프로세스가 끝난 경우(termination)
* 1,4번의 경우에는 선택의 여지 없이 새로운 프로세스가 선택되어야한다. 그러나 2,4번의 경우에는 ready state로 바뀐것이기 때문에 바로 CPU를 이어서 점유할 것인가를 선택할 수 있다.
* Scheduling을 1,4번의 상황에서만 하는 경우를 nonpreemptive(비선점), 그 외의 경우를 preemptive(선점)이라고 한다.
* 정리하면 CPU를 사용하고 있지 않은 프로세스가 사용중인 프로세스의 CPU를 뺏을 수 있으면 preemptive, 불가능하다면 nonpreemptive라고 할 수 있다.
* 대부분의 OS는 preemptive scheduling을 쓴다.

* Preemptive scheduling의 단점
  * Race condition 발생 가능성
  * 복잡한 커널 구조
* 그럼에도 preemptive scheduling을 쓰는 이유
  * Nonpreemptive는 매우 단순하고 구현하기 쉬운 커널구조를 가지지만 현재 작업이 끝날 때까지 CPU를 쓸 수 없다는 특징 때문에 현대 컴퓨팅의 가장 중요한 요소중 하나인 real-time computing면에서 성능이 매우 떨어질 수 밖에 없다.

### Dispatcher

* **Dispatcher** : CPU control을 scheduling된 프로세스에 넘겨주는 모듈
  * Switching context, Switching to user mode, Jumping to the proper execution location 등의 기능을 한다.
  * 모든 Context switch에서 실행되기 때문에 빠르게 동작 할수록 좋다.

<hr>

## 5.2 Scheduling Creteria

<br>
<hr>

### Reference

* Operating System Concepts 10th edition
